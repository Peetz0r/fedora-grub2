From 808b17c8d8b5a4b4744a7fa0bfe59474ca1509f3 Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Fri, 16 Mar 2018 16:22:20 -0400
Subject: [PATCH 216/216] Static

---
 Makefile.util.def         |   7 +++
 util/grub-mkconfig_lib.in |  46 ++++++++++++++++
 util/grub-set-uuids.in    | 134 ++++++++++++++++++++++++++++++++++++++++++++++
 util/grub.d/10_linux.in   |  20 ++++---
 4 files changed, 199 insertions(+), 8 deletions(-)
 create mode 100644 util/grub-set-uuids.in

diff --git a/Makefile.util.def b/Makefile.util.def
index fe392c24351..bbc38b894ad 100644
--- a/Makefile.util.def
+++ b/Makefile.util.def
@@ -1348,6 +1348,13 @@ script = {
   installdir = sbin;
 };
 
+script = {
+  name = grub-set-uuids;
+  common = util/grub-set-uuids.in;
+  mansection = 8;
+  installdir = sbin;
+};
+
 program = {
   name = grub-glue-efi;
   mansection = 1;
diff --git a/util/grub-mkconfig_lib.in b/util/grub-mkconfig_lib.in
index 70dc8d57e92..80674ef714d 100644
--- a/util/grub-mkconfig_lib.in
+++ b/util/grub-mkconfig_lib.in
@@ -128,6 +128,52 @@ EOF
   fi
 }
 
+add_device_modules ()
+{
+  local device=$1 && shift
+
+  old_ifs="$IFS"
+  IFS='
+'
+  partmap="`"${grub_probe}" --device ${device} --target=partmap`"
+  for module in ${partmap} ; do
+    case "${module}" in
+      netbsd | openbsd)
+        echo "insmod part_bsd";;
+      *)
+        echo "insmod part_${module}";;
+    esac
+  done
+
+  # Abstraction modules aren't auto-loaded.
+  abstraction="`"${grub_probe}" --device ${device} --target=abstraction`"
+  for module in ${abstraction} ; do
+    echo "insmod ${module}"
+  done
+
+  fs="`"${grub_probe}" --device ${device} --target=fs`"
+  for module in ${fs} ; do
+    echo "insmod ${module}"
+  done
+}
+
+get_device_uuid ()
+{
+  local device=$1 && shift
+  if [ "$#" -gt 0 ]; then
+    local variable=$1 && shift
+  else
+    local variable=root
+  fi
+  old_ifs="$IFS"
+  IFS='
+'
+
+  fs_uuid="`"${grub_probe}" --device ${device} --target=fs_uuid 2> /dev/null`"
+  IFS="$old_ifs"
+  echo "$fs_uuid"
+}
+
 prepare_grub_to_access_device ()
 {
   local device=$1 && shift
diff --git a/util/grub-set-uuids.in b/util/grub-set-uuids.in
new file mode 100644
index 00000000000..72c239b4ef5
--- /dev/null
+++ b/util/grub-set-uuids.in
@@ -0,0 +1,134 @@
+#! /bin/sh
+#
+# Set a default boot entry for GRUB.
+# Copyright (C) 2004,2009  Free Software Foundation, Inc.
+#
+# GRUB is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+# Initialize some variables.
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+bindir=@bindir@
+sysconfdir="@sysconfdir@"
+PACKAGE_NAME=@PACKAGE_NAME@
+PACKAGE_VERSION=@PACKAGE_VERSION@
+datarootdir="@datarootdir@"
+datadir="@datadir@"
+if [ "x$pkgdatadir" = x ]; then
+    pkgdatadir="${datadir}/@PACKAGE@"
+fi
+
+self=`basename $0`
+
+grub_editenv=${bindir}/@grub_editenv@
+bootdir=`echo "/@bootdirname@" | sed 's,//*,/,g'`
+grubdir=`echo "/@bootdirname@/@grubdirname@" | sed 's,//*,/,g'`
+grubenv=""
+
+export TEXTDOMAIN=@PACKAGE@
+export TEXTDOMAINDIR="@localedir@"
+
+# Usage: usage
+# Print the usage.
+usage () {
+    gettext_printf "Usage: %s [OPTION]\n" "$self"
+    gettext "Set the boot and root UUIDs for GRUB."; echo
+    echo
+    print_option_help "-h, --help" "$(gettext "print this message and exit")"
+    print_option_help "-V, --version" "$(gettext "print the version information and exit")"
+    dirmsg="$(gettext_printf "expect GRUB images under the directory DIR/%s instead of the %s directory" "@grubdirname@" "$grubdir")"
+    print_option_help "--boot-directory=$(gettext "DIR")" "$dirmsg"
+    print_option_help "--grub-environment=$(gettext "FILE")" "${grubdir}/grubenv"
+    #echo
+    #gettext "Report bugs to <bug-grub@gnu.org>."; echo
+}
+
+argument () {
+  opt=$1
+  shift
+
+  if test $# -eq 0; then
+      gettext_printf "%s: option requires an argument -- \`%s'\n" "$self" "$opt" 1>&2
+      exit 1
+  fi
+  echo $1
+}
+
+# Check the arguments.
+while test $# -gt 0
+do
+    option=$1
+    shift
+
+    case "$option" in
+    -h | --help)
+	usage
+	exit 0 ;;
+    -V | --version)
+	echo "$self (${PACKAGE_NAME}) ${PACKAGE_VERSION}"
+	exit 0 ;;
+
+# Accept for compatibility
+    --root-directory)
+	rootdir=`argument $option "$@"`; shift ;;
+    --root-directory=*)
+	rootdir=`echo "$option" | sed 's/--root-directory=//'` ;;
+
+    --boot-directory)
+	bootdir=`argument $option "$@"`; shift;;
+    --boot-directory=*)
+	bootdir=`echo "$option" | sed 's/--boot-directory=//'` ;;
+
+    --grub-environment)
+	grubenv=`argument $option "$@"`; shift;;
+    --grub-environment=*)
+	grubenv=`echo "$option" | sed 's/--grub-environment=//'` ;;
+
+    *)
+	gettext_printf "Unrecognized option \`%s'\n" "$option" 1>&2
+	usage
+	exit 1
+	;;
+    esac
+done
+
+if [ -z "$bootdir" ]; then
+    # Default bootdir if bootdir not initialized.
+    bootdir=/@bootdirname@
+
+    if [ -n "$rootdir" ] ; then
+        # Initialize bootdir if rootdir was initialized.
+        bootdir=${rootdir}/@bootdirname@
+    fi
+fi
+
+grubdir=`echo "${bootdir}/@grubdirname@" | sed 's,//*,/,g'`
+
+if [ -z "$grubenv" ]; then
+    grubenv="${grubdir}/grubenv"
+fi
+
+# Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
+GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
+GRUB_DEVICE_BOOT_UUID_GENERATED="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_uuid 2> /dev/null`" || true
+
+# Device containing our /boot/efi partition.  Usually not the same as GRUB_DEVICE.
+GRUB_DEVICE_BOOT_EFI="`${grub_probe} --target=device /boot/efi`"
+GRUB_DEVICE_BOOT_EFI_UUID_GENERATED="`${grub_probe} --device ${GRUB_DEVICE_BOOT_EFI} --target=fs_uuid 2> /dev/null`" || true
+
+$grub_editenv "${grubenv}" set "bootuuid=${GRUB_DEVICE_BOOT_EFI_UUID_GENERATED}"
+$grub_editenv "${grubenv}" set "rootuuid=${GRUB_DEVICE_BOOT_UUID_GENERATED}"
+
+# Bye.
+exit 0
diff --git a/util/grub.d/10_linux.in b/util/grub.d/10_linux.in
index f5daefb9d24..232f417d3e6 100644
--- a/util/grub.d/10_linux.in
+++ b/util/grub.d/10_linux.in
@@ -129,17 +129,21 @@ linux_entry ()
 
   if [ "x${GRUB_ENABLE_BLSCFG}" = "xtrue" ]; then
     if [ x$dirname = x/ ]; then
-      if [ -z "${prepare_root_cache}" ]; then
-        prepare_grub_to_access_device ${GRUB_DEVICE}
-      fi
+      add_device_modules "${GRUB_DEVICE}"
+      uuid="$(get_device_uuid "${GRUB_DEVICE}")"
+      ${grub_editenv} - set rootuuid="${uuid}"
     else
-      if [ -z "${prepare_boot_cache}" ]; then
-        prepare_grub_to_access_device ${GRUB_DEVICE_BOOT}
-      fi
+      add_device_modules "${GRUB_DEVICE_BOOT}"
+      uuid="$(get_device_uuid "${GRUB_DEVICE_BOOT}")"
+      ${grub_editenv} - set rootuuid="${uuid}"
     fi
+    if [ -d /sys/firmware/efi/efivars ]; then
+      bootefi_device="`${grub_probe} --target=device /boot/efi/`"
+      add_device_modules ${bootefi_device}
 
-    bootefi_device="`${grub_probe} --target=device /boot/efi/`"
-    prepare_grub_to_access_device ${bootefi_device} boot
+      uuid="$(get_device_uuid "${bootefi_device}")"
+      ${grub_editenv} - set bootuuid="${uuid}"
+    fi
 
     cat << EOF
 insmod blscfg
-- 
2.15.0

